<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS闭包 | PENG BlOG </title>
    <meta name="generator" content="VuePress 1.6.0">
    
    <meta name="description" content="
什么是“执行上下文”(也叫做“执行上下文环境”）？我们先不定义，先看以下几种情况。
第一种情况，变量声明，默认赋值为undefined
首先我们在浏览器控制台来调试一段代码。
`js
console.log(a) // Uncaught ReferenceError: a is not defined
console.log(a) // undefined
v ...">
    <link rel="preload" href="/assets/css/0.styles.3b407bb1.css" as="style"><link rel="preload" href="/assets/js/app.2081b9de.js" as="script"><link rel="preload" href="/assets/js/6.e971b65b.js" as="script"><link rel="preload" href="/assets/js/3.7df72e40.js" as="script"><link rel="preload" href="/assets/js/13.f25c2b77.js" as="script"><link rel="prefetch" href="/assets/js/10.28ca56ae.js"><link rel="prefetch" href="/assets/js/11.7155161e.js"><link rel="prefetch" href="/assets/js/12.a8cde50f.js"><link rel="prefetch" href="/assets/js/14.c5433b85.js"><link rel="prefetch" href="/assets/js/15.54d3db27.js"><link rel="prefetch" href="/assets/js/16.206b99e7.js"><link rel="prefetch" href="/assets/js/17.a2541f66.js"><link rel="prefetch" href="/assets/js/18.1a930651.js"><link rel="prefetch" href="/assets/js/4.970cf5ac.js"><link rel="prefetch" href="/assets/js/5.1c80739e.js"><link rel="prefetch" href="/assets/js/7.01076be7.js"><link rel="prefetch" href="/assets/js/8.4092820b.js"><link rel="prefetch" href="/assets/js/9.3b9ad554.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.3fc622a1.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3b407bb1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">PENG BlOG  </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/" class="nav-link">文章</a></li><li class="nav-item"><a href="/tag/" class="nav-link">标签</a></li><li class="nav-item"><a href="http://tjui.glinsunai.com/#/" target="_blank" rel="noopener noreferrer" class="nav-link external">组件库</a></li><li class="nav-item"><a href="https://github.com/myronyang" target="_blank" rel="noopener noreferrer" class="nav-link external">Github</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">PENG BlOG  </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/" class="nav-link">文章</a></li><li class="mobile-nav-item"><a href="/tag/" class="nav-link">标签</a></li><li class="mobile-nav-item"><a href="http://tjui.glinsunai.com/#/" target="_blank" rel="noopener noreferrer" class="nav-link external">组件库</a></li><li class="mobile-nav-item"><a href="https://github.com/myronyang" target="_blank" rel="noopener noreferrer" class="nav-link external">Github</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        JS闭包
      </h1> <div class="post-meta"><!----> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2018-9-25">
      Tue Sep 25 2018
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/tag/Javascript" data-v-42ccfcd5><span data-v-42ccfcd5>Javascript</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h2 id="执行上下文"><a href="#执行上下文" class="header-anchor">#</a> 执行上下文</h2> <p>什么是“执行上下文”(也叫做“执行上下文环境”）？我们先不定义，先看以下几种情况。</p> <h4 id="第一种情况-变量声明-默认赋值为undefined"><a href="#第一种情况-变量声明-默认赋值为undefined" class="header-anchor">#</a> 第一种情况，变量声明，默认赋值为undefined</h4> <p>首先我们在浏览器控制台来调试一段代码。</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// Uncaught ReferenceError: a is not defined</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
<span class="token keyword">var</span> a

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span>
</code></pre></div><p>第一个打印报错，因为a未定义。第二个、第三个输出都是undefined，说明浏览器在执行console.log(a)时，已经知道了a是undefined，但却不知道a是10（第三句中）。</p> <p>在一段js代码运行前，浏览器会做一些“准备工作”，其中就包括对变量的的声明，而不是赋值。</p> <p>变量赋值是在赋值语句执行的时候进行的。</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 首先声明a, 默认值为undefined</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span> <span class="token comment">// 给a赋值为10</span>
</code></pre></div><h4 id="第二种情况-直接给this赋值"><a href="#第二种情况-直接给this赋值" class="header-anchor">#</a> 第二种情况，直接给this赋值</h4> <p>我们知道无论在哪个位置获取this都是有值的。通常来讲this指向对应的执行环境，详细的下面会花专门一章来讲解this。</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> 
<span class="token comment">// Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}</span>
</code></pre></div><p>与第一种情况不同的是第一种只是对变量进行了声明，并没有赋值。而这种情况直接给this赋值。这也是“准备工作”情况要做的事情之一。</p> <h4 id="另外还有第三种情况-函数声明-和-函数表达式-。"><a href="#另外还有第三种情况-函数声明-和-函数表达式-。" class="header-anchor">#</a> 另外还有第三种情况, “函数声明“和“函数表达式“。</h4> <p>虽然两者都很常用，但是这两者在“准备工作”时，却是两种不同的情况。</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span> <span class="token comment">// ƒ f1() {}</span>
<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 函数声明</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f2<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
<span class="token keyword">var</span> <span class="token function-variable function">f2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 函数表达式</span>
</code></pre></div><p>以上代码“函数声明”我们看到了第二种情况，直接给f1赋值了。而函数表达式则是第一种情况。
在“准备工作”中对待函数表达式，就像对待<code>var a = 10</code>这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。</p> <p>::: warning 总结下在“准备工作”中完成了哪些工作</p> <ul><li>变量、函数表达式——变量声明，默认赋值为undefined。</li> <li>this——赋值。</li> <li>函数声明——赋值。</li></ul> <h4 id="这三种数据的准备情况我们称之为-执行上下文-或者-执行上下文环境-。"><a href="#这三种数据的准备情况我们称之为-执行上下文-或者-执行上下文环境-。" class="header-anchor">#</a> 这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。</h4> <p>:::</p> <p>上面所有的例子都是在全局环境下执行的。在js执行一段代码前，都会进行这些“准备工作”来生成执行上下文。
<strong>这个“代码段”其实分三种情况——全局代码，函数体，eval代码。</strong></p> <p>什么是代码段？就是一段文本形式的代码。</p> <h4 id="首先-全局代码是一种-就是手写文本到-script-标签里面的。"><a href="#首先-全局代码是一种-就是手写文本到-script-标签里面的。" class="header-anchor">#</a> 首先，全局代码是一种，就是手写文本到<code>&lt;script&gt;</code>标签里面的。</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;text/javascript&quot;</span><span class="token operator">&gt;</span>
  <span class="token comment">// 代码段...</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><h4 id="其次-eval代码接收的也是一段文本形式的代码-eval不常用-不推荐-。"><a href="#其次-eval代码接收的也是一段文本形式的代码-eval不常用-不推荐-。" class="header-anchor">#</a> 其次，eval代码接收的也是一段文本形式的代码(eval不常用，不推荐)。</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">'alert(123)'</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="最后-函数体是代码段是因为函数在创建时-本质上是-new-function-得来的-其中需要传入一个文本形式的参数作为函数体。"><a href="#最后-函数体是代码段是因为函数在创建时-本质上是-new-function-得来的-其中需要传入一个文本形式的参数作为函数体。" class="header-anchor">#</a> 最后，函数体是代码段是因为函数在创建时，本质上是 new Function(…) 得来的，其中需要传入一个文本形式的参数作为函数体。</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token string">'console.log(x)'</span><span class="token punctuation">)</span>
</code></pre></div><p>如果在函数中，除了以上数据之外，还会有其他数据。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// arguments封装函数参数的数组</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span> <span class="token comment">// [10]</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">// 10</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
</code></pre></div><p>以上代码展示了在函数体的语句执行之前，arguments变量和函数的参数都已经被赋值。从这里可以看出，<strong>函数每被调用一次，都会产生一个新的执行上下文环境</strong>。因为不同的调用可能就会有不同的参数。</p> <p>另外一点不同在于，<strong>函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域</strong>。用一个例子说明：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// a是自由变量</span>
	<span class="token comment">// 函数创建时，就确定了a要取值的作用域</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span>
	<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 打印‘10’，而不是‘20’</span>
<span class="token punctuation">}</span>
<span class="token function">bar</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
</code></pre></div><h4 id="总结完了函数的附加内容-我们就此要全面总结一下上下文环境的数据内容。"><a href="#总结完了函数的附加内容-我们就此要全面总结一下上下文环境的数据内容。" class="header-anchor">#</a> 总结完了函数的附加内容，我们就此要全面总结一下上下文环境的数据内容。</h4> <p>全局代码的上下文环境数据内容为：</p> <table><thead><tr><th>场景</th> <th style="text-align:center;">结果</th></tr></thead> <tbody><tr><td>普通变量（包括函数表达式），如： var a = 10;</td> <td style="text-align:center;">声明（默认赋值为undefined）</td></tr> <tr><td>函数声明，如： function fn() { }</td> <td style="text-align:center;">赋值</td></tr> <tr><td>this</td> <td style="text-align:center;">赋值</td></tr></tbody></table> <p>如果代码段是函数体，那么在此基础上需要附加：</p> <table><thead><tr><th>场景</th> <th style="text-align:center;">结果</th></tr></thead> <tbody><tr><td>参数</td> <td style="text-align:center;">   赋值   </td></tr> <tr><td>arguments</td> <td style="text-align:center;">赋值</td></tr> <tr><td>自由变量的取值作用域</td> <td style="text-align:center;">赋值</td></tr></tbody></table> <p>::: warning 给执行上下文环境下一个通俗的定义
在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。
:::</p> <p>在执行js代码时，会有数不清的函数调用次数，会产生许多个上下文环境。这么多上下文环境该如何管理，以及如何销毁而释放内存呢？下下节将通过“执行上下文栈”来解释这个问题。</p> <h2 id="this"><a href="#this" class="header-anchor">#</a> this</h2> <p>在说“执行上下文栈”前，先把this说一下。其实，this的取值，分四种情况。</p> <p>::: warning 强调一遍一个非常重要的知识点
<strong>在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。</strong></p> <p>因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。
:::</p> <h4 id="情况1-构造函数"><a href="#情况1-构造函数" class="header-anchor">#</a> 情况1：构造函数</h4> <p>所谓构造函数就是用来new对象的函数。其实严格来说，所有的函数都可以new一个对象，但是有些函数的定义是为了new一个对象，而有些函数则不是。另外注意，构造函数的函数名第一个字母大写（规则约定）。例如：Object、Array、Function等。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Jack'</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>year <span class="token operator">=</span> <span class="token number">1993</span>

	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// Foo {name: &quot;Jack&quot;, year: 1993}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> f1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f1<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 'jack'</span>
</code></pre></div><p>以上代码中，如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。</p> <p>注意，以上仅限new Foo()的情况，即Foo函数作为构造函数的情况。如果直接调用Foo函数，而不是new Foo()，情况就大不一样了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Jack'</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>year <span class="token operator">=</span> <span class="token number">1993</span>

	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}</span>
<span class="token punctuation">}</span>

<span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>这种情况下this是window，我们后文中会说到。</p> <h4 id="情况2-函数作为对象的一个属性"><a href="#情况2-函数作为对象的一个属性" class="header-anchor">#</a> 情况2：函数作为对象的一个属性</h4> <p>如果函数作为对象的一个属性时，<strong>并且作为对象的一个属性被调用时</strong>，函数中的this指向该对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
	x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
	<span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// Object {x: 10, fn: function}</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token comment">// 10</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>以上代码中，fn不仅作为一个对象的一个属性，而且的确是作为对象的一个属性被调用。结果this就是obj对象。</p> <p>如果fn函数不作为obj的一个属性被调用，会是什么结果呢？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
	x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
	<span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// Object {x: 10, fn: function}</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> fn <span class="token operator">=</span> obj<span class="token punctuation">.</span>fn
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如上代码，如果fn函数被赋值到了另一个变量中，并没有作为obj的一个属性被调用，那么this的值就是window，this.x为undefined。</p> <h4 id="情况3-函数用call或者apply调用"><a href="#情况3-函数用call或者apply调用" class="header-anchor">#</a> 情况3：函数用call或者apply调用</h4> <p>当一个函数被call和apply调用时，this的值就取传入的对象的值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
	x<span class="token operator">:</span> <span class="token number">10</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// Object {x: 10}</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token comment">// 10</span>
<span class="token punctuation">}</span>

<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="情况4-全局-调用普通函数"><a href="#情况4-全局-调用普通函数" class="header-anchor">#</a> 情况4：全局 &amp; 调用普通函数</h4> <p>在全局环境下，this永远是window。</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> window<span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><p>普通函数在调用时，其中的this也都是window。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">var</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token comment">// 10</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上代码很好理解，不过下面的情况需要注意一下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
	x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
	<span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>  <span class="token comment">// Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
		<span class="token punctuation">}</span>
		<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>函数f虽然是在obj.fn内部定义的，但是它仍然是一个普通的函数，this仍然指向window。</p> <h2 id="执行上下文栈"><a href="#执行上下文栈" class="header-anchor">#</a> 执行上下文栈</h2> <p>执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。<strong>处于活动状态的执行上下文环境只有一个</strong>。</p> <p><img src="http://gxzn-free.oss-cn-zhangjiakou.aliyuncs.com/Web-private-resource/Blog/closures/img1.png" alt="prototype"></p> <h4 id="可根据以下代码来详细介绍上下文栈的压栈、出栈过程。"><a href="#可根据以下代码来详细介绍上下文栈的压栈、出栈过程。" class="header-anchor">#</a> 可根据以下代码来详细介绍上下文栈的压栈、出栈过程。</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1.进入全局上下文环境</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> 
    fn<span class="token punctuation">,</span>
    <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">5</span>
    	<span class="token function">fn</span><span class="token punctuation">(</span>x <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token comment">// 3.进入fn函数上下文环境</span>
    <span class="token punctuation">}</span>

<span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">5</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y <span class="token operator">+</span> c<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// 2.进入bar函数上下文环境</span>
</code></pre></div><p>在执行代码之前，首先将创建全局上下文环境。</p> <table><thead><tr><th>全局上下文环境</th> <th style="text-align:center;"></th></tr></thead> <tbody><tr><td>a</td> <td style="text-align:center;">undefined</td></tr> <tr><td>fn</td> <td style="text-align:center;">undefined</td></tr> <tr><td>bar</td> <td style="text-align:center;">undefined</td></tr> <tr><td>this</td> <td style="text-align:center;">window</td></tr></tbody></table> <p>然后是代码执行。代码执行到<code>bar(10)</code>之前，上下文环境中的变量都在执行过程中被赋值。</p> <table><thead><tr><th>全局上下文环境</th> <th style="text-align:center;"></th></tr></thead> <tbody><tr><td>a</td> <td style="text-align:center;">10</td></tr> <tr><td>fn</td> <td style="text-align:center;">undefined</td></tr> <tr><td>bar</td> <td style="text-align:center;">undefined</td></tr> <tr><td>this</td> <td style="text-align:center;">window</td></tr></tbody></table> <p>执行到<code>bar(10)</code>，调用bar函数。</p> <p>跳转到bar函数内部，执行函数体语句之前，会创建一个新的执行上下文环境。</p> <table><thead><tr><th>(bar函数)执行上下文环境</th> <th style="text-align:center;"></th></tr></thead> <tbody><tr><td>b</td> <td style="text-align:center;">undefined</td></tr> <tr><td>x</td> <td style="text-align:center;">10</td></tr> <tr><td>arguments</td> <td style="text-align:center;">[10]</td></tr> <tr><td>this</td> <td style="text-align:center;">window</td></tr></tbody></table> <p>并将这个执行上下文环境压栈，设置为活动状态。</p> <p><img src="http://gxzn-free.oss-cn-zhangjiakou.aliyuncs.com/Web-private-resource/Blog/closures/img2.png" alt="prototype"></p> <p>执行到<code>fn(x + b)</code>，又调用了fn函数。进入fn函数，在执行函数体语句之前，会创建fn函数的执行上下文环境，并压栈，设置为活动状态。</p> <p><img src="http://gxzn-free.oss-cn-zhangjiakou.aliyuncs.com/Web-private-resource/Blog/closures/img3.png" alt="prototype"></p> <p>待<code>fn(x + b)</code>执行完毕，即fn函数执行完毕后，此次调用fn所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。</p> <p><img src="http://gxzn-free.oss-cn-zhangjiakou.aliyuncs.com/Web-private-resource/Blog/closures/img4.png" alt="prototype"></p> <p>同理，待<code>bar(10)</code>执行完毕，即bar函数执行完毕后，调用bar函数所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。</p> <p><img src="http://gxzn-free.oss-cn-zhangjiakou.aliyuncs.com/Web-private-resource/Blog/closures/img5.png" alt="prototype"></p> <h4 id="其实以上我们所演示的是一种比较理想的情况。有一种情况-而且是很常用的一种情况-无法做到这样干净利落的说销毁就销毁。这种情况就是闭包。"><a href="#其实以上我们所演示的是一种比较理想的情况。有一种情况-而且是很常用的一种情况-无法做到这样干净利落的说销毁就销毁。这种情况就是闭包。" class="header-anchor">#</a> 其实以上我们所演示的是一种比较理想的情况。有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是闭包。</h4> <h2 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h2> <p>常说“javascript没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句。例如在if、for中。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> status <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&quot;jack&quot;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// jack</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">// 10 </span>
</code></pre></div><p>ES6新增了let命令用来进行变量声明，只在let命令所在代码块内有效。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
	<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span>
	<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">4</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 3</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// underfind</span>
</code></pre></div><p>::: warning 除了“javascript没有块级作用域”，还需知道
<strong>javascript除了全局作用域之外，只有函数可以创建的作用域。</strong></p> <p>我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式。
:::</p> <h4 id="作用域是一个很抽象的概念-类似于一个-地盘-。"><a href="#作用域是一个很抽象的概念-类似于一个-地盘-。" class="header-anchor">#</a> 作用域是一个很抽象的概念，类似于一个“地盘”。</h4> <p><img src="http://gxzn-free.oss-cn-zhangjiakou.aliyuncs.com/Web-private-resource/Blog/closures/img6.png" alt="prototype"></p> <p>如上图，全局代码和fn、bar两个函数都会形成一个作用域。而且，作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的。例如，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。</p> <p><strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</strong>。例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。</p> <p>例如jQuery源码的最外层是一个自动执行的匿名函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">window<span class="token punctuation">,</span> underfind</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span>
</code></pre></div><p>原因就是在jQuery源码中，声明了大量的变量，这些变量将通过一个函数被限制在一个独立的作用域中，而不会与全局作用域或者其他函数作用域的同名变量产生冲突。</p> <h4 id="我们把作用域和上下文环境结合起来说一下-会理解的更深一些"><a href="#我们把作用域和上下文环境结合起来说一下-会理解的更深一些" class="header-anchor">#</a> 我们把作用域和上下文环境结合起来说一下，会理解的更深一些</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 全局作用域</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    b <span class="token operator">=</span> <span class="token number">2</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// fn作用域</span>
	<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span>
		c <span class="token operator">=</span> <span class="token number">30</span>

	<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// bar作用域</span>
		<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span>
			d <span class="token operator">=</span> <span class="token number">400</span>
	<span class="token punctuation">}</span>

	<span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
	<span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

</code></pre></div><p>如上，我们在上文中已经介绍了，除了全局作用域之外，每个函数都会创建自己的作用域，<strong>作用域在函数定义时就已经确定了。而不是在函数调用时确定</strong>。</p> <ul><li>第一步，在加载程序时，已经确定了全局上下文环境，并随着程序的执行而对变量就行赋值。</li></ul> <table><thead><tr><th>全局上下文环境</th> <th style="text-align:center;"></th></tr></thead> <tbody><tr><td>a</td> <td style="text-align:center;">1</td></tr> <tr><td>b</td> <td style="text-align:center;">2</td></tr> <tr><td>fn</td> <td style="text-align:center;">ƒ fn()</td></tr> <tr><td>其他</td> <td style="text-align:center;">... ...</td></tr></tbody></table> <ul><li>第二步，程序执行到<code>fn(1)</code>处，调用fn(1)，此时生成此次调用fn函数时的上下文环境，压栈，并将此上下文环境设置为活动状态。</li></ul> <table><thead><tr><th>fn(1)上下文环境</th> <th style="text-align:center;"></th></tr></thead> <tbody><tr><td>x</td> <td style="text-align:center;">1</td></tr> <tr><td>a</td> <td style="text-align:center;">10</td></tr> <tr><td>b</td> <td style="text-align:center;">30</td></tr> <tr><td>bar</td> <td style="text-align:center;">ƒ bar(x)</td></tr> <tr><td>其他</td> <td style="text-align:center;">... ...</td></tr></tbody></table> <ul><li>第三步，程序执行到<code>bar(10)</code>处，调用bar(10)，生成此次调用的上下文环境，压栈，并设置为活动状态。</li></ul> <table><thead><tr><th>bar(10)上下文环境</th> <th style="text-align:center;"></th></tr></thead> <tbody><tr><td>x</td> <td style="text-align:center;">10</td></tr> <tr><td>a</td> <td style="text-align:center;">100</td></tr> <tr><td>d</td> <td style="text-align:center;">400</td></tr> <tr><td>其他</td> <td style="text-align:center;">... ...</td></tr></tbody></table> <ul><li>第四步，执行完<code>bar(10)</code>，bar(10)调用完成。则bar(10)上下文环境被销毁。接着执行到<code>bar(20)</code>，调用bar(20)，则又生成bar(20)的上下文环境，压栈，设置为活动状态。</li></ul> <table><thead><tr><th>bar(20)上下文环境</th> <th style="text-align:center;"></th></tr></thead> <tbody><tr><td>x</td> <td style="text-align:center;">20</td></tr> <tr><td>a</td> <td style="text-align:center;">100</td></tr> <tr><td>d</td> <td style="text-align:center;">400</td></tr> <tr><td>其他</td> <td style="text-align:center;">... ...</td></tr></tbody></table> <ul><li>第五步，执行完<code>bar(20)</code>，则bar(20)调用结束，其上下文环境被销毁。此时会回到fn(1)上下文环境，变为活动状态。</li></ul> <table><thead><tr><th>fn(1)上下文环境</th> <th style="text-align:center;"></th></tr></thead> <tbody><tr><td>x</td> <td style="text-align:center;">1</td></tr> <tr><td>a</td> <td style="text-align:center;">10</td></tr> <tr><td>b</td> <td style="text-align:center;">30</td></tr> <tr><td>其他</td> <td style="text-align:center;">... ...</td></tr></tbody></table> <ul><li>第六步，执行完<code>fn(1)</code>，fn(1)执行完成之后，fn(1)上下文环境被销毁，全局上下文环境又回到活动状态。</li></ul> <table><thead><tr><th>全局上下文环境</th> <th style="text-align:center;"></th></tr></thead> <tbody><tr><td>a</td> <td style="text-align:center;">1</td></tr> <tr><td>b</td> <td style="text-align:center;">2</td></tr> <tr><td>其他</td> <td style="text-align:center;">... ...</td></tr></tbody></table> <p><strong>作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值</strong>。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，<strong>作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了</strong>。</p> <h2 id="自由变量到作用域链"><a href="#自由变量到作用域链" class="header-anchor">#</a> 自由变量到作用域链</h2> <p>什么是“自由变量”？</p> <p>在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">20</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token comment">// 这里x就是自由变量</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上述代码中，b的值在fn作用域中取，因为b就是在fn中定义。而x的值就需要在另一个作用域中取，但是到哪个作用域中取呢？</p> <p><strong>有人说过要到父作用域中取，其实有时候这种解释会产生歧义</strong>。例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">20</span>
	<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 10</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">show</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
</code></pre></div><p>所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切——<strong>要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记</strong>——其实这就是所谓的“静态作用域”。</p> <p>对于本文第一段代码，在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取——无论fn函数将在哪里调用。</p> <p>上面描述的只是跨一步作用域去寻找。</p> <p>如果跨了一步，还没找到呢？——接着跨！一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。</p> <p>这个一步一步“跨”的路线，我们称之为——作用域链。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">10</span>

	<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token comment">// 20</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> bar
<span class="token punctuation">}</span>

<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	b <span class="token operator">=</span> <span class="token number">200</span>

<span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>上述代码中，fn()返回的是bar函数，赋值给x。执行x()，即执行bar()。取b的值时，直接在fn作用域中取出。取a的值时，先在fn()作用域中取，但是没取到，只能转向创建fn的那个作用域中找。</p> <h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <p>对于闭包笼统的理解只需要知道应用的两种情况即可--<strong>函数作为返回值，函数作为参数传递。</strong></p> <h4 id="第一-函数作为返回值"><a href="#第一-函数作为返回值" class="header-anchor">#</a> 第一，函数作为返回值</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> max <span class="token operator">=</span> <span class="token number">10</span>

	<span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> f1 <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span>
</code></pre></div><p>以上代码，bar函数作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值。至于如何跨作用域取值，可以参考上一节。</p> <h4 id="第二-函数作为参数被传递"><a href="#第二-函数作为参数被传递" class="header-anchor">#</a> 第二，函数作为参数被传递</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> max <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span>
	<span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> max <span class="token operator">=</span> <span class="token number">100</span>
	<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
</code></pre></div><p>以上代码，fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。</p> <p>::: warning 自由变量跨作用域取值</p> <h4 id="要去创建这个函数的作用域取值-而不是-父作用域-。"><a href="#要去创建这个函数的作用域取值-而不是-父作用域-。" class="header-anchor">#</a> 要去创建这个函数的作用域取值，而不是“父作用域”。</h4> <p>理解了这一点，以上两端代码中，自由变量如何取值应该比较简单。
:::</p> <p>讲到闭包，除了结合着作用域之外，还需要结合着执行上下文栈来说。</p> <p>前面讲执行上下文栈时，提到当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。</p> <p>但是在最后说到——有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。<strong>这就是需要理解闭包的核心内容</strong>。</p> <p>可以拿本文的第一段代码（稍作修改）来分析一下。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 全局作用域</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
	<span class="token comment">// fn作用域</span>
	<span class="token keyword">var</span> max <span class="token operator">=</span> <span class="token number">10</span>

	<span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
		<span class="token comment">// bar作用域</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> f1 <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	max <span class="token operator">=</span> <span class="token number">100</span>
<span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="第一步-代码执行前生成全局上下文环境-并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。"><a href="#第一步-代码执行前生成全局上下文环境-并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。" class="header-anchor">#</a> 第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。</h4> <table><thead><tr><th>全局上下文环境</th> <th style="text-align:center;"></th></tr></thead> <tbody><tr><td>fn</td> <td style="text-align:center;">ƒ fn()</td></tr> <tr><td>f1</td> <td style="text-align:center;">underfind</td></tr> <tr><td>max</td> <td style="text-align:center;">underfind</td></tr> <tr><td>其他</td> <td style="text-align:center;">... ...</td></tr></tbody></table> <h4 id="第二步-代码执行到var-f1-fn-产生fn-执行上下文环境-压栈-并设置为活动状态。"><a href="#第二步-代码执行到var-f1-fn-产生fn-执行上下文环境-压栈-并设置为活动状态。" class="header-anchor">#</a> 第二步，代码执行到<code>var f1 = fn()</code>，产生fn()执行上下文环境，压栈，并设置为活动状态。</h4> <table><thead><tr><th>fn上下文环境</th> <th style="text-align:center;"></th></tr></thead> <tbody><tr><td>max</td> <td style="text-align:center;">10</td></tr> <tr><td>其他</td> <td style="text-align:center;">... ...</td></tr></tbody></table> <h4 id="第三步-代码执行完var-f1-fn-fn-调用完成。按理说应该销毁掉fn-的执行上下文环境-但是这里不能这么做。因为执行fn-时-返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是-返回的这个函数体中-还有一个自由变量max要引用fn作用域下的fn-上下文环境中的max。因此-这个max不能被销毁-销毁了之后bar函数中的max就找不到值了。"><a href="#第三步-代码执行完var-f1-fn-fn-调用完成。按理说应该销毁掉fn-的执行上下文环境-但是这里不能这么做。因为执行fn-时-返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是-返回的这个函数体中-还有一个自由变量max要引用fn作用域下的fn-上下文环境中的max。因此-这个max不能被销毁-销毁了之后bar函数中的max就找不到值了。" class="header-anchor">#</a> 第三步，代码执行完<code>var f1 = fn()</code>，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。因为执行fn()时，<strong>返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域</strong>。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。</h4> <p>因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。</p> <p>即，执行到<code>max = 100</code>时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完到<code>max = 100</code>时，全局上下文环境中的max被赋值为100。</p> <table><thead><tr><th>全局上下文环境</th> <th style="text-align:center;"></th></tr></thead> <tbody><tr><td>fn</td> <td style="text-align:center;">ƒ fn()</td></tr> <tr><td>f1</td> <td style="text-align:center;">ƒ bar(x)</td></tr> <tr><td>max</td> <td style="text-align:center;">100</td></tr> <tr><td>其他</td> <td style="text-align:center;">... ...</td></tr></tbody></table> <h4 id="第四步-执行到f1-15-执行f1-15-即执行bar-15-创建bar-15-上下文环境-并将其设置为活动状态。"><a href="#第四步-执行到f1-15-执行f1-15-即执行bar-15-创建bar-15-上下文环境-并将其设置为活动状态。" class="header-anchor">#</a> 第四步，执行到<code>f1(15)</code>，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。</h4> <table><thead><tr><th>bar(15)上下文环境</th> <th style="text-align:center;"></th></tr></thead> <tbody><tr><td>x</td> <td style="text-align:center;">15</td></tr> <tr><td>其他</td> <td style="text-align:center;">... ...</td></tr></tbody></table> <p>执行<code>bar(15)</code>时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。</p> <p>这里的重点就在于，创建bar函数在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文还存在与栈中，因为bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。</p> <p><strong>使用闭包会增加内容开销，现在很明显了吧！</strong></p> <h4 id="第五步-执行完fn-15-就是上下文环境的销毁过程-这里就不再赘述了。"><a href="#第五步-执行完fn-15-就是上下文环境的销毁过程-这里就不再赘述了。" class="header-anchor">#</a> 第五步，执行完<code>fn(15)</code>就是上下文环境的销毁过程，这里就不再赘述了。</h4> <p>闭包和作用域、上下文环境有着密不可分的关系，需一步步理解,</p></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#执行上下文" title="执行上下文">执行上下文</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#this" title="this">this</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#执行上下文栈" title="执行上下文栈">执行上下文栈</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#作用域" title="作用域">作用域</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#自由变量到作用域链" title="自由变量到作用域链">自由变量到作用域链</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#闭包" title="闭包">闭包</a></div></div></div></div> <footer class="footer" data-v-fdbf4940><div class="footer-left-wrap" data-v-fdbf4940><ul class="contact" data-v-fdbf4940><li class="contact-item" data-v-fdbf4940><a href="https://github.com/myronyang" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-fdbf4940><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-fdbf4940><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-fdbf4940></path></svg>
          
        </a></li><li class="contact-item" data-v-fdbf4940><a href="/2018/09/25/javascript-closure/821253835@qq.com.html" class="nav-link" data-v-fdbf4940><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail" data-v-fdbf4940><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z" data-v-fdbf4940></path><polyline points="22,6 12,13 2,6" data-v-fdbf4940></polyline></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-fdbf4940><ul class="copyright" data-v-fdbf4940><li class="copyright-item" data-v-fdbf4940><a href="/2018/09/25/javascript-closure/.html" class="nav-link" data-v-fdbf4940>MyronYang © 2020</a></li></ul></div></footer></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.2081b9de.js" defer></script><script src="/assets/js/6.e971b65b.js" defer></script><script src="/assets/js/3.7df72e40.js" defer></script><script src="/assets/js/13.f25c2b77.js" defer></script>
  </body>
</html>
